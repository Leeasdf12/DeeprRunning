# -*- coding: utf-8 -*-
"""(03/24) 이민성 수업내용 정리.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1HzYkHAjuKUediEwPnzFs85YaXaTsnTX4

# 리스트

* 다양한 자료형을 복합적으로 사용할 수 있는 것이 특징이다.
"""

# 비어있는 리스트 생성 방법 2가지
a = list()
ㅁ = []

# 다양한 자료형을 포함하는 리스트 선언
b = [1, "문자열", -0.5, '안녕']

# 리스트를 복사하는 방법
c = list(b)

# 리스트 출력
print(a)
print(b)
print(c)

"""* 리스트를 생성할 수 있는 방법들이다.

# 리스트 인덱싱

* 리스트도 문자열과 유사하게 인덱싱 및 슬라이싱이 가능하다.
"""

# 리스트 요소 출력 확인
a = [1, "문자열", -0.5, '안녕']
print('a[0]:', a[0])
print('a[1]:', a[1])
print('a[2]:', a[2])
print('a[3]:', a[3])

# 리스트 요소를 문자열로 변환하여 출력
b = [1, 2, [3, 4, 5]]
print("b[0] " + str(b[0]))
print("b[1] " + str(b[1]))
print("b[2] " + str(b[2]))

# 중첩 리스트 접근 (다중 인덱싱)
c = [1, 2, 3, ['python', ' is', 'good', ['a', 'b', 'c']]]
print(c[3][3][1])

"""* 리스트는 인덱스를 사용해 특정 요소에 접근 가능
* 리스트 안에 리스트도 포함될 수 있으며, 중첩 리스트의 요소는 다중 인덱싱으로 접근 가능
* 문자열과 함께 출력할 때는 str()을 사용해 형 변환이 요구될 때도 있음
"""

# 중첩 리스트를 포함한 리스트 선언
b = [1, 2, 3, ['python', 'is', 'good', ['a', 'b', 'c']]]

# 리스트 슬라이싱 예제
print(b[0:3])

# 중첩 리스트에서 슬라이싱
print(b[3][2:4])

"""* 문자열처럼 슬라이싱 가능"""

a = [1,2,3]
b = [4,5,6]

# 리스트 덧셈
c = a + b
print('a + b = ', c)

# 리스트 곱셈
print('a * 3 = ', a*3)
print('b * 4 = ',b*4)

"""* 해당 코드처럼 리스트에 덧셈, 곱셈이 가능"""

# 리스트 선언
b = [1, 2, 3, ['python', 'is', 'good', ['a', 'b', 'c']]]

# 리스트의 전체 길이 출력
print(len(b))  # 최상위 리스트 요소 개수

# 중첩 리스트의 길이 출력
print(len(b[3]))  # b[3] 리스트의 요소 개수

# 문자열 요소의 길이 출력
print(len(b[3][0]))  # 'python' 문자열의 길이

"""* 중첩 리스트의 요소는 다중 인덱싱을 사용해 접근 가능
* 리스트의 요소가 문자열인 경우 문자열의 길이가 반환됨

# 리스트 요소 삭제와 수정
"""

# 리스트 선언
a = [1, 2, 3, 4, 6]
print(a

# 리스트 값 변경
a[4] = 5
print(a)

# 리스트 요소 삭제
del a[0]
print(a)

del a[2:]  #2번 인덱스부터 끝까지 삭제
print(a)

# 리스트에 요소 추가
a.append(4)
print(a)

# 리스트를 추가 (중첩 리스트)
a.append([5, 6, 7, 8])
print(a)

"""* del a[x]는 x번째 요솟값을 삭제
* 슬라이싱 기법을 사용하여 리스트의 요소 여러 개를 한꺼번에 삭제 가능
* append로 리스트에 요소를 추가할 수 있음
"""

# 정렬
a = [1, 4, 3, 2]
a.sort()
print(a)

"""* 리스트 정렬 - sort"""

# 뒤집기
a = ['a', 'c', 'b']
a.reverse()
print(a)

"""* 리스트 뒤집기 - reverse
* 현재 리스트를 그대로 뒤집어서 정렬 X
"""

# 인덱스값(위칫값)
a = [1, 2, 3]
print(a.index(3))
print(a.index(1))

"""* 인덱스 값(위칫값) - index
* 리스트안에 값의 위치를 찾아줌 (없으면 에러)
"""

# 요소 삽입
a = [1, 2, 3]
print(a)
a.insert(0, 4)
print(a)

"""* 리스트에 요소 삽입 - insert
* 위 코드 기준 0번째에 4를 삽입한다.
"""

# 요소 제거
a = [1, 2, 3, 1, 2, 3]
print(a)
a.remove(3) #델리트는 위치로 지우지만 리무브는 값으로 맨앞에 하나 지움 (없는건 에러)
print(a)

"""* 리스트 요소 제거 - remove"""

# 요소 추출
a = [1, 2, 3, 4, 5]
print(a)

b = a.pop(2)
print(a)
print(b)

"""* 리스트 요소 끄집어 내기 - pop
* pop()은 리스트의 맨 마지막 요소를 리턴하고 그 요소는 삭제
* 다른 변수로 추출해낼때 용이
"""

# 개수 세기
a = [1, 2, 3, 1]
print(a.count(1)) #리스트안에 1이라는 숫자의 갯수

"""* 리스트에 포함된 요소 x의 개수 세기 - count

# 튜플

* 리스트와 마찬가지로 모든 자료형을 담을 수 있지만, 튜플은 한 번 생성하면 변경 불가능
"""

# 튜플 생성 예제
t1 = ()
t2 = (1,)
t3 = (1, 2, 3)
t4 = 1, 2, 3
t5 = ('a', 'b', ('ab', 'cd'))

print(t1)
print(t2)
print(t3)
print(t4)
print(t5)

"""* 소괄호(()) 로 생성
* t2 = (1,)처럼 단지 1개의 요소만을 가질 때는 요소 뒤에 쉼표(,)를 반드시 붙여야 함
* t4 처럼 소괄호를 생략해도 됨
* 튜플안에 값을 변경시 에러 발생

#불 자료형(BOOL)
"""

a = True
b = False

# 변수 타입 출력
print(type(a))
print(type(b))

# bool() 함수로 데이터의 참/거짓 판별
print(bool([1, 2, 3]))
print(bool([]))
print(0)
print(bool(3))

"""* type 변수로 자료형 확인
* 값이 없거나 0이면 False
* 값이 있으면 True로 리턴

#비교 연산자
"""

a = 10
b = 5

# 비교 연산자 예제
print(a == b)  # False (같은지 비교)
print(a != b)  # True  (다른지 비교)
print(a > b)   # True  (초과)
print(a < b)   # False (미만)
print(a >= b)  # True  (이상)
print(a <= b)  # False (이하)

"""#논리 연산자"""

x = True
y = False

# 논리 연산자 예제
print(x and y)  # False (둘 다 True여야 True)
print(x or y)   # True  (하나라도 True면 True)
print(not x)    # False (논리값을 반대로 변환)
print(not y)    # True  (논리값을 반대로 변환)

"""# 딕셔너리

* Key와 Value를 한쌍으로 가지는 자료형
* 순차적으로 접근하지 않고, 오직 Key를 통해서 Value값에 접근.
* 순서가 없기 떄문에, 인덱싱 및 슬라이싱이 불가능.
* Key값은 고유한 값으로, 중복되는 Key값을 사용하면 안됨.
"""

# 딕셔너리 생성
dic = {'사과': 'apple', '바나나': 'banana', '메론': 'melon', '복숭아': 'peach'}

# 딕셔너리 출력
print(dic)

# 특정 키의 값 가져오기
print(dic['사과'])  # apple
print(dic['바나나'])  # banana

"""# 딕셔너리 추가 및 삭제"""

# 딕셔너리 선언
dic = {1:'one', 2:'two'}
print(dic)

# 새로운 키-값 추가
dic[3] = '쓰리'
print(dic)

# 중복 키에 값 추가
dic[3] = 'three'
print(dic)

# 특정 키 삭제
del dic[2]
print(dic)

print(dic[1])

# 키가 중복될 경우 마지막 값이 적용
test_dic = {1:'one', 2:'two', 2:'둘', 3:'three',3:'셋', 4:'four'}
print(test_dic)

"""* 딕셔너리를 추가할때 기존에 존재하는 키 값에 넣을 경우 맨 마지막에 넣은 값으로 저장
* 딕셔너리를 삭제할때 해당 키 값의 인덱스로 삭제 가능

# 딕셔너리 관련 함수
"""

dic = {'사과': 'apple', '바나나': 'banana', '메론': 'melon', '복숭아': 'peach'}
print(dic.keys()) # 키 목록 출력
print(dic.values()) # 값 목록 출력
print(dic.items()) # (키, 값) 튜플 목록 출력

print(dic.get('바나나')) # '바나나'의 값 가져오기
print(dic['바나나']) # get 생략 가능

print('사과' in dic)
print('수박' in dic)


dic.clear() # 딕셔너리 클리어
print(dic)

"""* Key 리스트 만들기 - keys
* Value 리스트 만들기 - values
* Key, Value 쌍 얻기 - items
* Key로 Value 얻기 - get
* 해당 Key가 딕셔너리 안에 있는지 조사하기 - in
* Key: Value 쌍 모두 지우기 - clear

#집합 자료형

* 집합(set)과 관련된 것을 처리하기 위해 만든 자료형
* **중복을 허용하지 않는다.**
* 순서가 없다.
"""

# 집합(set) 생성
s1 = set([1,2,3,3,2])
s2 = set('i am a boy')
s3 = set([1,5,6])

print(s1)
print(s2)
print(s3)

# 집합을 리스트로 변환
li = list(s1)
print(li)
print(li[0])

"""* 집합으로 생성시 중복값은 사라짐
* 문자열은 한 글자씩 분리 + 중복 제거
* 문자열은 랜덤으로 저장됨
* 리스트로 변환 시 중복값은 제거된 상태로 변환됨

#집합 연산
"""

s1 = set([1,2,3,3,2])
s2 = set('i am a boy')
s3 = set([1,5,6])

#교집합
print(s1 & s3)

#합집합
print(s1 | s3)

#차집합
print(s1 - s3)

"""* set 자료형을 정말 유용하게 사용하는 경우는 교집합, 합집합, 차집합을 구할 때임
 * 교집합(&), 합집합(|), 차집합(-)

# 집합 관련 함수
"""

s1 = set([1, 2, 3])
s1.add(4) #값 1개 추가
print(s1)

s1.update([5, 6, 7]) #값 여러개 추가
print(s1)

s1.remove(2) #특정 값 제거
print(s1)

"""* 리스트뿐만 아니라 튜플, 문자열도 넣을 수 있음
* 제거하려는 값이 집합에 없으면 오류가 발생

# 조건문 (if문)
* 특정 조건을 평가하고, 그 조건에 따라 다른 코드를 실행
* 참(True), 거짓(False)을 판단하여 조건에 맞는 문장을 수행하는것이 조건문
"""

# 사용자의 문자 입력 받기
character = input("문자를 입력하세요: ")

# 입력한 문자가 'a' 인지 판별
if character == 'a':
  print("입력한 문자는 'a'입니다.")
else:
  print("입력한 문자는 'a'가 아닙니다.")

"""* **if문의 기본 구조**  
if 조건문:  
    수행할_문장1  
    수행할_문장2  
    ...  
else:  
    수행할_문장A  
    수행할_문장B  
    ...  
* **if문은 들여쓰기로 if문에서 수행할 문장을 구분한다.**
* **else 문은 if문 조건을 충족하지 못했을 경우 수행한다.**


"""

# 수학점수와 영어점수가 모두 60점 이상이면 합격을 토옵
# and연산자: true, ture -> true

math = 70
eng = 50

# 하나라도 False라면, 조건문이 수행되지 않음
if math>=60 and eng>=60:
  print("합격입니다.")
else:
  print("불합격입니다.")

"""* **and, or, not**

1.   and(x or y) :	x와 y 둘 중 하나만 참이어도 참이다.
2.   or(x and y) : 	x와 y 모두 참이어야 참이다.
3.   not(not x)	: x가 거짓이면 참이다.

# IN 연산자
"""

list1 = [1, 2, 3, 4, 5]
tuple1 = (2, 3, 4, 5)

# in : ~~가 ~~안에 있니? -> True, False
print(1 in list1)
print(1 in tuple1)

"""* 파이썬에서 있는 조건문이다.
 * in 연산자를 통해 해당 내용이 리스트,튜플,문자열 안에 있는지 확인 할 수 있고, 결과 값으로 True, False를 반환한다.

# *만약 주머니에 돈이 있으면 택시를 타고, 없으면 걸어가라고 명령*

pocket = ['phone','wallet','money','IDcard']
"""

pocket = ['phone','wallet','money','IDcard']

# in을 활용한 방법
if 'money' in pocket:
  print("택시를 타세요")
else:
  print("걸어가세요")

# not in을 활용한 방법
if 'money' not in pocket:
  print("걸어가세요")
else:
  print("택시를 타세요")

"""# *만약 주머니에 돈이 있거나 카드가 있으면 택시를 타고, 없으면 걸어가라고 명령*

pocket = ['phone','IDcard','money','card']
"""

pocket = ['phone','IDcard','money','card']

# if, elif, else 활용
if 'money' in pocket:
  print("택시를 타세요")
elif 'card' in pocket:
  print("택시를 타세요")
else:
  print("걸어가세요")


# 논리 연산자 활용
if ('money' in pocket) or ('card' in pocket):
  print("택시를 타세요")
else:
  print("걸어가세요")